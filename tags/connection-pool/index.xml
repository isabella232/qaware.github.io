<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Connection Pool on QAware | Software Engineering Blog</title><link>https://blog.qaware.de/tags/connection-pool/</link><description>Recent content in Connection Pool on QAware | Software Engineering Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright Â© 2020, QAware GmbH; all rights reserved.</copyright><lastBuildDate>Tue, 17 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.qaware.de/tags/connection-pool/index.xml" rel="self" type="application/rss+xml"/><item><title>HikariCP on Jakarta EE</title><link>https://blog.qaware.de/posts/2020-11-17-hikaricp-on-jakarta-ee/</link><pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate><guid>https://blog.qaware.de/posts/2020-11-17-hikaricp-on-jakarta-ee/</guid><description>Motivation A JDBC connection pool is essential for application servers where several parallel requests need access to a database. Especially on high load, an efficient JDBC connection pool is important to avoid locked threads, delayed request processing or partial service interruptions.
Payara, closely related to the GlassFish reference implementation of Jakarta EE (JEE), comes with its own implementation of a JDBC connection pool. Under high load our application experienced locking deficiencies when it comes to high load.</description></item></channel></rss>